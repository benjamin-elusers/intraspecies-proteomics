---
title: "RNA-seq, Ribo-seq and proteomic "
date: "`r format(Sys.time(), 'Last Modified: %d-%b-%Y %R %p')`"
subtitle: "How does gene expression vary at different expression scales?"
author: "[Elie Teyssonniere](https://github.com/elielink/)"
mail: "elieteyssonniere@gmail.com"
github: "elielink"
home: "https://github.com/elielink/"
output:
  rmdformats::downcute:
    self_contained: true
    thumbnails: false
    lightbox: true
    gallery: true
    highlight: tango
    code_download: true
    code_folding: hide
    fig_caption: yes
    keep_md: yes
    toc_depth: 3
    toc_float:
      toc_collapsed: true
    number_sections: true
    theme: lumen
  editor_options: 
    chunk_output_type: console
---

<!-- Github Logo -->
<a href="https://github.com/elielink/" class="github-corner" aria-label="Visit my Github">
  <svg width="80" height="80" viewBox="0 0 250 250" style="fill:#69b3a2; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true">
    <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
    <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
    <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path>
  </svg>
</a>

<style> 
.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}
@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}
@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}
</style>

```{r setup, include=FALSE, echo=F, warnings=F, message=F}
knitr::opts_chunk$set(echo = T, collapse = T, cache.lazy = F,autodep = T)
suppressPackageStartupMessages({
  library(xfun)
  # Load  package ---------------------------------------
  dep.pkg = c("corrplot",
"ggtree",
"gtools",
"pbapply",
"gridExtra",
"GGally",
"dplyr",
"performance", 
"ggplot2",
"ggfortify",
"affy",
"graphics",
"tidyverse",
"gplots",
"data.table",
"ggpubr",
"ggcorrplot",
"plotly",
"ggsignif",
'ape')

  xfun::pkg_attach2(dep.pkg)

  source("functions.R")

})
# turn off annoying messages from dplyr::summarise
options(dplyr.summarise.inform = FALSE)
``` 

# General dataset summary {.tabset .tabset-pills}


## Our datasets

**_RNA-seq & Ribo-seq of 8 natural isolates of Saccharomyces cerevisiae_**

We performed both ribosome profiling and RNA sequencing on eight _S. cerevisiae_ natural isolates coming from very diverse ecological environments and being genetically strongly different ([Peter et al., 2018](https://www.nature.com/articles/s41586-018-0030-5)). These isolates were cultivated in Synthetic Complete (SC) up to mid-log phase, harvested and flash-frozen. The RNA-seq and Ribo-seq experiment was performed in collaboration with the Riken institute in Japan.
```{r dataset}
# General dataset summary {.tabset .tabset-pills}

## Our dataset

isolates = c('CPI','CMP','AMH','CQC','BPL','BTT','BED','BAN')
RNA_seq_data = readRDS('RNA_seq.RDS')
Ribo_seq_data = readRDS('Ribo_seq.RDS')
n = nrow(RNA_seq_data)
strains = fread('strains.csv',data.table = F)
strains = strains[strains$`Standardized name`%in%isolates,c(1,2,3,4,9,10,11,16)]
require(DT)
datatable(strains, rownames = FALSE, caption = NULL,
               filter = "top", escape = FALSE, style = "default",
               width = NULL, height = NULL)
```

Our data encompassed **`r n`** genes. The data was normalized using TPM normalization where for each gene in each isolate, we divided the raw count by the ORF length and we applied a per million factor (total read count / 1,000,000)


```{r dataset2}
# General dataset summary {.tabset .tabset-pills}

## Our dataset


p1= ggcorr(RNA_seq_data ,method = c("everything", "spearman"), label = T, label_round = 2, midpoint = 0.75, limits = c(0.6,1), size = 2)+
  ggtitle('RNA-seq correlation matrix')
p2=ggcorr(Ribo_seq_data ,method = c("everything", "spearman"), label = T, label_round = 2, midpoint = 0.75, limits = c(0.6,1), size = 2)+
  ggtitle('Ribo-seq correlation matrix')

grid.arrange(p1,p2, ncol=2)
```

We also calculated a Translation efficiency value which correspond, for each gene in each isolate, to the Ribo-seq TPM value divided by the RNA-seq TPM value. In brief, this represents how well a transcript will be used for translation.

## Overlap with proteomic

```{r dataset3}
# General dataset summary {.tabset .tabset-pills}

## Overlap with proteomic

proteomic_WIS2 = readRDS('log2-int_lfq-na_imputed-norm_median.rds')

n = nrow(proteomic_WIS2)


prot_gene_name = fread('test.csv', fill = T, data.table = F)
prot_gene_name[ grep('\\(',prot_gene_name$Chromosome),"Chromosome"]=NA
prot_gene_name[is.na(prot_gene_name$Chromosome),"Chromosome"]=prot_gene_name[is.na(prot_gene_name$Chromosome),"V8"]
prot_gene_name= prot_gene_name[,-8]
prot_gene_name=prot_gene_name[!duplicated(prot_gene_name$prot_names),]
rownames(prot_gene_name)=prot_gene_name$prot_names

a = lapply(isolates,function(i){

  b = proteomic_WIS2[,grep(i,colnames(proteomic_WIS2))]
  return(rowMeans(b,na.rm = T))
})
a= setNames(a,isolates)
a = as.data.frame(a)
rownames(a)= rownames(proteomic_WIS2)
proteomic_WIS_mean2 = a
rownames(proteomic_WIS_mean2) = rownames(proteomic_WIS2)
proteomic_WIS_mean2=na.omit(proteomic_WIS_mean2)

b=prot_gene_name[!(duplicated(prot_gene_name$prot_names)),]
rownames(b)=b$prot_names
a  =proteomic_WIS_mean2
a = a[rownames(a)%in%b$prot_names,]
rownames(a)=b[rownames(a),"ID"]
proteomic_WIS_mean_filtered2=a


temp = intersect(rownames(proteomic_WIS_mean_filtered2),rownames(RNA_seq_data))
a = cbind(proteomic_WIS_mean_filtered2[temp,],log2(cbind(RNA_seq_data[temp,],Ribo_seq_data[temp,])))
for(i in c(0,8,16)){
  if(i==0)(colnames(a)[1:8]=paste(colnames(a)[1:8],'Prot',sep='_'))
  if(i==8)(colnames(a)[i+(1:8)]=paste(colnames(a)[i+(1:8)],'RNA',sep='_'))
  if(i==16)(colnames(a)[i+(1:8)]=paste(colnames(a)[i+(1:8)],'Ribo',sep='_'))
}

e= a
#e = log2(e)

a = nrow(e)
boxplot(e)
```

Our proteomic data encompassed **`r n`** genes. The overlap between the two datasets encompassed **`r a`** (after several filtration of some missing values). The data between the different data sets needed to be normalized so it can be studied together (see graph above). We therefore performed _loess_ normalization to obtain equally distributed data (see below)

```{r dataset4}
e = normalize.loess(e,log.it=F,verbose = F)
boxplot(e, las=2)
df_final2=e
```

# Post transcriptional buffering {.tabset .tabset-pills}

The post-transcriptional buffering (PTB) is a phenomenon where transcriptional variations tend to be buffered as the expression process progresses (add ref). It has been observed in different situations... To be completed

It is possible to detect this phenomenon in different ways:

## Correlation between isolate

Using the normalized data, we performed Spearman correlation between all the isolate profile in each expression level separately (using the median value of the replicate for the proteomic data)

Comparing the correlation values, it reveals that the profiles tended to be more and more similar as the expression process progresses (increasing of the correlation coefficient values), bringing a first proof of the presence of the phenomenon across our 8 isolates. 

```{r PTB1}

d= list()

a= df_final2[, grep('Prot', colnames(df_final2))]
d[['prot']]=cor(a,method = 's')[lower.tri(cor(a,method = 's'))]
a= df_final2[, grep('RNA', colnames(df_final2))]
d[['RNA']]=cor(a,method = 's')[lower.tri(cor(a,method = 's'))]
a = df_final2[, grep('Ribo', colnames(df_final2))]
d[['Ribo']]=cor(a,method = 's')[lower.tri(cor(a,method = 's'))]
d= as.data.frame(d)
d= melt(d)
d$variable=factor(d$variable,levels = c('RNA','Ribo','prot'))
b = combn(as.character(unique(d$variable)),2)
b = apply(b,2,function(i){
  return(list(i[1],i[2]))
})
lapply(1:length(b),function(i){
  b[[i]]<<-unlist(b[[i]])
})


ggplot(d,aes(x=variable, y=value,fill=variable))+
  geom_boxplot()+
  theme_classic()+
  xlab('')+
  ylab('Rho')+
  stat_compare_means(comparisons = b)
```


## Variation quantification 

It is also possible to explore PTB by quantifying the variation in each pairwise comparison. Basically, for each gene in each isolate pairwise comparison, we use the absolute value of the log2 transformed fold to represent the intensity of the expression variation between the 2 isolates (|log2(FC)|). The more this value increases, the more a gene displays variable regulation between isolate.

We calculated this value in each pairwise comparison, for each gene and at each expression level. We found that the intensities of the variations were decreasing as long as the expression process progresses, supporting once again the presence of the PTB phenomenon in our dataset.

```{r PTB2}

a = combn(isolates,2)

b = pbapply(a,2,function(i){
  i<<-i
  d = list()
  e = df_final2[,grep(pattern = paste(i,collapse = '|'),colnames(df_final2))]
  
  c = e[,1:2]
  c= c[,1]/c[,2]
  c= abs(log2(c))
  
  d[['prot']] = c
  
  c = e[,3:4]
  c= c[,1]/c[,2]
  c= abs(log2(c))
  
  d[['RNA']] = c
  
  c = e[,5:6]
  c= c[,1]/c[,2]
  c= abs(log2(c))
  
  d[['Ribo']] = c
  c =lapply(d,function(j){
    j<<-j
    
  })
  return(c)
})

pblapply(1:length(b), function(i){
  i<<-i
  b[[i]] <<- as.data.frame(b[[i]])
  return('')
})

a = do.call(rbind, b)
a = melt(a)

a$variable=factor(a$variable,levels = c('RNA','Ribo','prot'))
b = combn(as.character(unique(a$variable)),2)
b = apply(b,2,function(i){
  return(list(i[1],i[2]))
})
lapply(1:length(b),function(i){
  b[[i]]<<-unlist(b[[i]])
})

ggplot(a,aes(variable,value, fill=variable))+
  geom_boxplot()+
  scale_y_log10()+
  stat_compare_means(comparisons = b)+
  theme_classic()+
  xlab('')+
  ylab('|log2(FC)|')

```

## Euclidean distances between the profiles

Euclidean distances can also give information on how variable datasets can be. We once again used the normalized data to calculate Euclidean distances between the profile in each expression level.

Consistently to the previous results, we found that the distances were lower and lower as the expression process progresses, suggesting once again that the expression variations were decreased. This also supported the presence of the PTB phenomenon

```{r PTB3}

a = dist(t(df_final2))
a = as.matrix(a)
a = as.data.frame(a)
b=lapply(c('RNA','Ribo','Prot'), function(i){
  i<<-i
  a = df_final2[,grep(i, colnames(df_final2))]
  a = dist(t(a))
  a = as.matrix(a)
  a= a[lower.tri(a)]
  return(a)
})
names(b)=  c('RNA','Ribo','Prot')
b=as.data.frame(b)
b = melt(b)

c = combn(as.character(unique(b$variable)),2)
c = apply(c,2,function(i){
  return(list(i[1],i[2]))
})
lapply(1:length(c),function(i){
  c[[i]]<<-unlist(c[[i]])
})

ggplot(b,aes(x=variable,y=value, fill=variable))+
  geom_boxplot()+
  theme_classic()+
  ylab('Euclidean distance')+
  xlab('')+
  stat_compare_means(comparisons = c)

```

## Variance comparison

A simple variance calculation can also give a clue on the variation intensity of gene expression. We calculated the variance in all dataset for each gene and found that it tended to be higher at the transcription level, lower at the protein abundance level (with the translation level being in the middle), which was in accordance with the previous exploration

```{r PTB4}

a=lapply(c('RNA','Ribo','Prot'), function(i){
  i<<-i
  a = df_final2[,grep(i, colnames(df_final2))]
  a=apply(a,1 ,var)
  return(a)
})
names(a)= c('RNA','Ribo','Prot') 
a =as.data.frame(a)
b=a
b = melt(b)
c = combn(as.character(unique(b$variable)),2)
c = apply(c,2,function(i){
  return(list(i[1],i[2]))
})
lapply(1:length(c),function(i){
  c[[i]]<<-unlist(c[[i]])
})

ggplot(b,aes(x=variable,y=value, fill=variable))+
  geom_boxplot()+
  theme_classic()+
  ylab('Variance')+
  xlab('')+
  stat_compare_means(comparisons = c)+
  scale_y_log10()

```


# Discrete factors influencing expression evolution on the different layers {.tabset .tabset-pills}

Expression evolution can be explored in each layer using several methods. One of them uses the construction of phylogeny trees using the expression data at each expression layer (transcriptome, translatome, proteome). This method has been used previously for expression evolution exploration in mammals ([Wang et al., 2020](https://www.nature.com/articles/s41586-020-2899-z)). We tried to applied this method to our data sets. We used the normalized data (encompassing **`r nrow(df_final2)`** genes).

## Transcriptome, translatome and proteome trees

```{r tree1}
par(mfrow= c(1,3))
a =lapply(c('Prot', 'RNA','Ribo'), function(i){
  i<<-i
b = dist(t(df_final2[, grep(i, colnames(df_final2))]))
a = nj(b)
c = sum(a$edge.length)

d =lapply(1:1000, function(j){
  b = dist(t(df_final2[sample(x=1:nrow(df_final2),size = nrow(df_final2),replace = T), grep(i, colnames(df_final2))]))
  a = nj(b)
  
  sum(a$edge.length)
})
d= unlist(d)
c=c(c,qnorm(0.975)*sd(d)/sqrt(length(d)))
c= setNames(c,c('length', 'err'))

plot(a,type='u', main = i)
c
})
a= do.call(rbind,a)
rownames(a)= c('Prot', 'RNA','Ribo')
a= as.data.frame(a)
a$level=rownames(a)
a$level=factor(a$level,levels = c('RNA','Ribo','Prot'))
```

The measure of the global expression evolution can be achieved using the total length of the tree (see below, error bar correspond the to 95% confidence interval of the tree length using 1000 steps boot-straping)

```{r tree2}

ggplot(a, aes(level, fill=level, y= length))+
  geom_bar(stat = 'identity',width = 0.5, alpha= 0.8)+
  geom_errorbar(aes(x=level, ymin=length-err, ymax=length+err), width=0.1)+
  theme_classic()

```

Consistently with the detection of the post-transcriptional buffering, the expression evolution seems to be more and more constrained at each step of gene expression (Constraint RNA < Constraint Ribo < Constraint Prot).

## Characteristic influencing gene expression evolution

It is possible to explore how some gene characteristics can influence gene expression evolution by comparing the length of a tree generated using the gene having these characteristics with tree lengths obtain with all or random set of genes. However, it necessary to first check if the number of genes used to generate a tree influence the final tree length. By sub sampling the number of gene to generate the trees (100 iterations with each possible number of gene starting from 10) it is possible to detect an effect on final tree length. It is therefore important to take into account the number of gene tested and compare this to trees generated with the same amount of genes. 

```{r tree3}
set.seed(123)
#d=lapply(rep(10:nrow(df_final2),1000),function(j){
 # 
#  temp= df_final2[sample(1:nrow(df_final2),j),]
#  a =lapply(c('Prot', 'RNA','Ribo'), function(i){
#    i<<-i
#    b = dist(t(temp[, grep(i, colnames(temp))]))
#    a = nj(b)
#    c = sum(a$edge.length)
#    
#  })
#  a= t(data.frame(length=a))
 # rownames(a)= c('Prot', 'RNA','Ribo')
#  a= as.data.frame(a)
  #a$num=j
#  return(a)
#})
#d= do.call(rbind,d)
#d$type= NA
#d[grep('Prot', rownames(d)),"type"]='Prot'
#d[grep('RNA', rownames(d)),"type"]='RNA'
#d[grep('Ribo', rownames(d)),"type"]='Ribo'
#d$type=factor(d$type,levels = c('RNA','Ribo','Prot'))
#write_rds(d,'control_tree_length.RDS')
d= read_rds('control_tree_length_loess.RDS')
ggplot(d,aes(x=num,y=V1, col= type))+
  geom_point(alpha=0.6)+
  theme_classic()+
  xlab('Number of genes')+
  ylab("Tree length")


control_tree_length = d
gene_feature = read_rds("PREDICTORS-fungi_orthologs-nomiss.rds")
a=gene_feature[,(sapply(gene_feature, class)=='logical')]
a =as.data.frame(a)
rownames(a)=gene_feature$ORF
a = a[intersect(rownames(a), rownames(df_final2)),]
a=a[,sapply(a,sum)>9]
```



We'll be using gene characteristics (quantified with Boolean values: TRUE or FALSE) generated with several databases (see [Yeastomic](https://github.com/benjamin-elusers/yeastomics)). Not all genes were encompassed and therefore we'll be using the gene overlapping between the expression datasets and the characteristic database (**`r nrow(a)`** genes). To detect whether or not a characteristic influences the gene expression evolution, we compared the length L of a tree obtained with N genes displaying the characteristic with lengths obtained with 100 trees generated by randomly select N genes. The 100 length being globally normally distributed, it is possible to obtain the Cumulative Distribution Function the length L compared to the lengths of the 100  random trees. For instance, the characteristic _cat_genomics.sgd.chr_A_ (which is: is the gene on the chromosome 1?) encompassed **`r sum(a[,1])`** gene in the our dataset (**`r sum(a[,1])`** out of **`r nrow(a)`** genes overlapping between our expression data and the characteristic database). 
```{r tree4}

b = nj(dist(t(df_final2[rownames(df_final2)%in%rownames(a)[a$cat_genomics.sgd.chr_A], grep('RNA', colnames(df_final2))])))
b=sum(b$edge.length)
c= pnorm(b,mean = mean(control_tree_length[control_tree_length$num==sum(a[,1])&control_tree_length$type=='RNA',"V1"]),sd =sd(control_tree_length[control_tree_length$num==sum(a[,1])&control_tree_length$type=='RNA',"V1"]) )
```
The length of the tree generated with these 30 gene using RNA-seq data is **`r b`**. The probability (not corrected) of getting this length with random trees = **`r c`**

```{r tree5}
par(mfrow=c(1,1))
plot(density(control_tree_length[control_tree_length$num==sum(a[,1])&control_tree_length$type=='RNA',"V1"]),main = 'Tree length distribution')
abline(v=b, col='red')
```

We performed this analysis for **`r ncol(a)`** characteristics at each expression level. We corrected the probability values (false discovery rate correction) and using a corrected probability value threshold of 0.001 to select the characteristic impacting gene expression.

```{r tree6}
B= apply(a,2, function(i){
  i<<-i
  b = rownames(a)[i]
  c = df_final2[b,]
  d =sapply(c('Prot', 'RNA','Ribo'), function(j){
    j<<-j
    b = dist(t(c[, grep(j, colnames(c))]))
    a = nj(b)
    e = sum(a$edge.length)
    
    return(e)
  })
  e =control_tree_length[control_tree_length$num== sum(i),]
  
  e=lapply(c('Prot', 'RNA','Ribo'), function(j){
  c= e[e$type%in%j,"V1"]
  b = d[j]
  if(b>mean(c)){ a=pnorm(mean = mean(c),sd = sd(c),b,lower.tail = F)}
  if(b<mean(c)){ a=pnorm(mean = mean(c),sd = sd(c),b)} 
  return(c(a, b/mean(c)))
  })
  e    
})

B2=lapply(B, function(i){
  i<<-i
  unlist(i)
})

B3= do.call(rbind,B2)


for(i in c(1,3,5)){
  B3[,i]=p.adjust(B3[,i], method = 'fdr')
}
temp = B3
B4 = B3[B3[,1]<0.001|B3[,5]<0.001|B3[,3]<0.001,]

```
We detected **`r nrow(b)`** characteristics influencing gene expression evolution (either in one direction or another)

```{r tree7}

require(knitr)
colnames(B4)=c('P_prot','tree length charac/random (prot)','P_RNA','tree length charac/random (RNA)','P_Ribo','tree length charac/random (Ribo)')
kable(B4, caption = 'Characteristic influecing Gene expression evolution')
b=B4
```

Consistently with previous findings, we found that features related to "interaction" tended to be related to more stringent gene expression evolution. 

```{r tree8}
c = melt(b[grep('interaction',rownames(b)),c(2,4,6)])[,3]

d = melt(b[-grep('interaction',rownames(b)),c(2,4,6)])[,3]

boxplot(c,d,xaxt = "n", ylab = "Length ratio")
axis(1, at=1:2,labels=c('Interaction', 'Other'))
temp = wilcox.test(c,d)
temp = temp$p.value
temp = as.numeric(temp)

```

The ratios between the interaction categories' tree lengths and the random tree are lower than the other significant features' ratios (Wilcoxon p-value = **`r temp`**). Using each dataset individually it was still possible to observe these differences. 

```{r tree9}
c = melt(b[,c(2,4,6)])
c$Interaction = ifelse(1:nrow(c)%in% grep('interaction',c$Var1),'Interaction','Other')

ggplot(c, aes(y = value, fill = Interaction, x= Var2))+
  geom_boxplot()+
  stat_compare_means(method = 'wilcox.test',label = "p.signif", 
                     symnum.args = list(cutpoints = c(0, 0.0001, 0.001, 0.01, 0.05, 1), 
                                        symbols = c("****", "***", "**", "*", "ns")))+
  theme_classic()+
  scale_fill_brewer()+
  xlab('')+
  ylab('')
```

Another consistent results with previous findings: we found that features related to "metabolism" tended to be related to faster gene expression evolution. 
```{r tree10}

c = melt(b[grep('metabolism',rownames(b)),c(2,4,6)])[,3]

d = melt(b[-grep('metabolism',rownames(b)),c(2,4,6)])[,3]

boxplot(c,d,xaxt = "n", ylab = "Length ratio")
axis(1, at=1:2,labels=c('Metabolism', 'Other'))
temp = wilcox.test(c,d)
temp = temp$p.value
temp = as.numeric(temp)
```

The ratios between the metabolism categories' tree lengths and the random tree are higher than the other significant features' ratios (Wilcoxon p-value = **`r temp`**). Here again, using each dataset individually it was still possible to observe these differences. 

```{r tree11}

c = melt(b[,c(2,4,6)])
c$metabolism = ifelse(1:nrow(c)%in% grep('metabolism',c$Var1),'metabolism','Other')

ggplot(c, aes(y = value, fill = metabolism, x= Var2))+
  geom_boxplot()+
  stat_compare_means(method = 'wilcox.test',label = "p.signif", 
                     symnum.args = list(cutpoints = c(0, 0.0001, 0.001, 0.01, 0.05, 1), 
                                        symbols = c("****", "***", "**", "*", "ns")))+
  theme_classic()+
  scale_fill_brewer()+
  xlab('')+
  ylab('')

```


More generally it seem that gene expression evolution was slower at the proteomic level (consistently with the previous results)

```{r tree12}

a= b[,c(4,6,2)]
a = melt(a)

c = combn(as.character(unique(a$Var2)),2)
c = apply(c,2,function(i){
  return(list(i[1],i[2]))
})
lapply(1:length(c),function(i){
  c[[i]]<<-unlist(c[[i]])
})

ggplot(a, aes(x= Var2, y = value))+
  geom_violin(aes(fill = Var2))+
  geom_boxplot(width= 0.1)+
  theme_classic()+
  xlab('')+
  ylab('Tree ratio')+
  theme(legend.position = 'none')+
  stat_compare_means(comparisons = c)
```



# Continuous factors influencing expression variation on the different layers {.tabset .tabset-pills}

We then sought to also focus on continuous gene characteristics (see [Yeastomic](https://github.com/benjamin-elusers/yeastomics)), and we used this time a step wise linear regression approach. The goal is to construct a model that explains as good as possible a measure of gene expression evolution. We used the mean |log2(FC)| for each gene. As observed previously, this value decreases as the expression process progresses

```{r SLR1}
#|log2(FC)|
a = combn(isolates,2)

b = pbapply(a,2,function(i){
  i<<-i
  d = list()
  e = df_final2[,grep(pattern = paste(i,collapse = '|'),colnames(df_final2))]
  
  c = e[,1:2]
  c= c[,1]/c[,2]
  c= abs(log2(c))
  
  d[['Prot']] = c
  
  c = e[,3:4]
  c= c[,1]/c[,2]
  c= abs(log2(c))
  
  d[['RNA']] = c
  
  c = e[,5:6]
  c= c[,1]/c[,2]
  c= abs(log2(c))
  
  d[['Ribo']] = c
  c =lapply(d,function(j){
    j<<-j
    setNames(j,rownames(df_final2))
  })
  return(c)
})

pblapply(1:length(b), function(i){
  i<<-i
  b[[i]] <<- as.data.frame(b[[i]])
  return('')
})

a = do.call(cbind, b)
c= list()
c[['Prot']]=rowMeans(a[,grep('Prot',colnames(a))])
c[['RNA']]=rowMeans(a[,grep('RNA',colnames(a))])
c[['Ribo']]=rowMeans(a[,grep('Ribo',colnames(a))])

c= as.data.frame(c)

log2FC_all_gene = c

c = melt(log2FC_all_gene)
c$variable=factor(c$variable,levels = c('RNA','Ribo','Prot'))

ggplot(c,aes(value, col= variable))+
  geom_density(size=2)+
  scale_x_log10()+
  theme_classic()+
  xlab('|log2(FC)|')

a=gene_feature[,(sapply(gene_feature, class)=='numeric')]
a =as.data.frame(a)
rownames(a)=gene_feature$ORF
a = a[intersect(rownames(a), rownames(df_final2)),]

```

We had a total of **`r ncol(a)`** numeric features encompassing **`r nrow(a)`** genes. Before performing the step wise regression, we pre selected the features with a minimal impact of gene expression variation. To do so, we performed individually a linear regression using each feature against |log2(FC)| at each expression level. We selected the feature which results in a regression with R-squared > 0.01 in at least one expression layer. 

```{r SLR2}
d = lapply(colnames(a), function(i){
  i<<-i
  b = lapply(c('RNA','Ribo','Prot'), function(j){
    c = log2FC_all_gene[rownames(a),grep(j, colnames(log2FC_all_gene))]
    c=summary(lm((c)~(a[,i])))
    c$r.squared
  })  
  return(unlist(b))
})
d = do.call(rbind,d)
d = apply(d,1, function(i){
  i<<-i
  if((T %in% (i>0.01))){
    return(T)
  }
  if(!(T %in% (i>0.01))){
    return(F)
  }
})
a = a[,unlist(d)]
```

This resulted in the selection of **`r ncol(a)`** feature. We performed the step wise regression using the _stepAIC()_ function in _R_. The factors which had a _Pr(>|t|)_<0.001 were kept and considered as influencing gene expression variation

```{r SLR3}
#b=pblapply(c('RNA','Ribo','prot'), function(i){
#  i<<-i
#  c = log2FC_all_gene[rownames(a),grep(i, colnames(log2FC_all_gene))]
#  c= cbind(c,a)
#  d = lm(c~., data=c)
#  d = stepAIC(d, direction = "both", 
#              trace = F)
#  return(d)
#})

#write_rds(b, "Step_Regression.rds")
b = readRDS("Step_Regression.rds")
names(b)= c('RNA','Ribo','Prot')
for( i in 1: length(b)){
  a = b[[i]]
  a = summary(a)
  a= a$coefficients
  a=a[a[,4]<0.001,]
  rownames(a)[2:length(rownames(a))] = substr(rownames(a)[2:length(rownames(a))],5,100)
  b[[i]] = a
}

```

We detected *`r nrow(b$RNA)`* features affecting the transcription layer:

```{r SLR4}

knitr::kable(b$RNA)

```

We detected *`r nrow(b$Ribo)`* features affecting the translation layer:

```{r SLR5}

knitr::kable(b$Ribo)

```

We detected *`r nrow(b$Prot)`* features affecting the proteome layer:

```{r SLR6}

knitr::kable(b$Prot)

```

# Session Info {-}

```{r session-info}
sessionInfo()
```